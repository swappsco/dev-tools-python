#!/bin/bash

# Pre-push hook
# 1. Validates branch names (ClickUp ID or conventional format)
# 2. Runs custom commands from .dev-hooks.yml config file (optionally filtered by file types)

# Colors optimized for macOS Terminal
RED='\x1b[31m'
GREEN='\x1b[32m'
YELLOW='\x1b[33m'
BLUE='\x1b[34m'
MAGENTA='\x1b[35m'
CYAN='\x1b[36m'
WHITE='\x1b[37m'
BOLD='\x1b[1m'
DIM='\x1b[2m'
NC='\x1b[0m'

# Get project root
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
CONFIG_FILE="$PROJECT_ROOT/.dev-hooks.yml"

# Check if we're pushing a tag (allow without validation)
# Read stdin to detect tag pushes
while read local_ref local_sha remote_ref remote_sha; do
    if [[ "$local_ref" == refs/tags/* ]]; then
        # Pushing a tag, allow it
        exit 0
    fi
done

branch_name=$(git symbolic-ref --short HEAD 2>/dev/null)

# If we can't get branch name (detached HEAD, etc.), allow push
if [ -z "$branch_name" ]; then
    exit 0
fi

# ============================================================================
# YAML Parser (simple, no dependencies)
# ============================================================================

yaml_get() {
    local key="$1"
    local file="$2"

    if [ ! -f "$file" ]; then
        echo ""
        return
    fi

    if [[ "$key" == *"."* ]]; then
        local parent="${key%%.*}"
        local child="${key#*.}"
        awk -v parent="$parent" -v child="$child" '
            $0 ~ "^"parent":" { in_section=1; next }
            in_section && /^[a-zA-Z]/ { in_section=0 }
            in_section && $0 ~ "^  "child":" {
                gsub(/^  [a-zA-Z_-]+:[ ]*/, "")
                gsub(/^[ \t]+|[ \t]+$/, "")
                gsub(/^["'\'']|["'\'']$/, "")
                gsub(/^[ \t]+|[ \t]+$/, "")
                print
                exit
            }
        ' "$file"
    else
        awk -v key="$key" '
            $0 ~ "^"key":" {
                gsub(/^[a-zA-Z_-]+:[ ]*/, "")
                gsub(/^[ \t]+|[ \t]+$/, "")
                gsub(/^["'\'']|["'\'']$/, "")
                gsub(/^[ \t]+|[ \t]+$/, "")
                print
                exit
            }
        ' "$file"
    fi
}

yaml_get_commands() {
    local file="$1"

    if [ ! -f "$file" ]; then
        return
    fi

    awk '
        /^pre-push:/ { in_prepush=1; next }
        in_prepush && /^[a-zA-Z]/ { in_prepush=0 }
        in_prepush && /^  commands:/ { in_commands=1; next }
        in_commands && /^  [a-zA-Z]/ { in_commands=0 }
        in_commands && /^    - name:/ {
            gsub(/^    - name:[ ]*/, "")
            gsub(/^["'\'']|["'\'']$/, "")
            name=$0
        }
        in_commands && /^      run:/ {
            gsub(/^      run:[ ]*/, "")
            gsub(/^["'\'']|["'\'']$/, "")
            print name "|" $0
        }
    ' "$file"
}

# ============================================================================
# File Filter Check
# ============================================================================

# Check if there are changes matching the file filter
has_matching_files() {
    local filter="$1"

    if [ -z "$filter" ]; then
        # No filter, always run
        return 0
    fi

    # Get the remote and branch we're pushing to
    local remote_ref=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    if [ -z "$remote_ref" ]; then
        # No upstream, check all commits on this branch vs main/master
        local base_branch="main"
        if ! git rev-parse --verify main >/dev/null 2>&1; then
            base_branch="master"
        fi
        remote_ref="$base_branch"
    fi

    # Get list of changed files between remote and local
    local changed_files=$(git diff --name-only "$remote_ref"...HEAD 2>/dev/null)

    if [ -z "$changed_files" ]; then
        # No changes to push
        return 1
    fi

    # Check if any file matches the filter pattern
    # Support multiple patterns separated by comma: "*.py,*.js"
    IFS=',' read -ra patterns <<< "$filter"
    for pattern in "${patterns[@]}"; do
        # Trim whitespace
        pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Convert glob pattern to grep regex
        # *.py -> \.py$
        local regex=$(echo "$pattern" | sed 's/\./\\./g; s/\*/.*/g')

        if echo "$changed_files" | grep -qE "$regex"; then
            return 0
        fi
    done

    return 1
}

# ============================================================================
# Branch Validation
# ============================================================================

validate_branch() {
    local branch="$1"

    local skip_validation=$(yaml_get "pre-push.skip_branch_validation" "$CONFIG_FILE")
    if [ "$skip_validation" = "true" ]; then
        return 0
    fi

    local allowed_branches="^(master|main|develop|staging|production)$"
    local clickup_pattern="^CU-[a-zA-Z0-9]+$"
    local conventional_pattern="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|hotfix|release)/.+$"

    if echo "$branch" | grep -qE "$allowed_branches"; then
        return 0
    fi

    if echo "$branch" | grep -qE "$clickup_pattern"; then
        return 0
    fi

    if echo "$branch" | grep -qE "$conventional_pattern"; then
        return 0
    fi

    echo ""
    echo -e "${RED}${BOLD}┌──────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${RED}${BOLD}│  ✖ PUSH REJECTED - Invalid branch name                       │${NC}"
    echo -e "${RED}${BOLD}└──────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    echo -e "${WHITE}${BOLD}Your branch:${NC}"
    echo -e "  ${DIM}\"${branch}\"${NC}"
    echo ""
    echo -e "${CYAN}${BOLD}Allowed formats:${NC}"
    echo ""
    echo -e "  ${WHITE}1. ClickUp ID:${NC}"
    echo -e "     ${MAGENTA}CU-xxxxxxxxx${NC}"
    echo -e "     ${DIM}\$ git checkout -b \"CU-86b7f42fd\"${NC}"
    echo ""
    echo -e "  ${WHITE}2. Conventional:${NC}"
    echo -e "     ${GREEN}<type>${NC}${DIM}/${NC}${WHITE}<description>${NC}"
    echo -e "     ${DIM}Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, hotfix, release${NC}"
    echo -e "     ${DIM}\$ git checkout -b \"feat/user-login\"${NC}"
    echo -e "     ${DIM}\$ git checkout -b \"fix/header-bug\"${NC}"
    echo ""
    echo -e "  ${WHITE}3. Special branches:${NC}"
    echo -e "     ${GREEN}master${NC}, ${GREEN}main${NC}, ${GREEN}develop${NC}, ${GREEN}staging${NC}, ${GREEN}production${NC}"
    echo ""
    return 1
}

# ============================================================================
# Django Smart Tests
# ============================================================================

get_modified_django_apps() {
    # Get the remote ref to compare against
    local remote_ref=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    if [ -z "$remote_ref" ]; then
        local base_branch="main"
        if ! git rev-parse --verify main >/dev/null 2>&1; then
            base_branch="master"
        fi
        remote_ref="$base_branch"
    fi

    # Get modified Python files
    local changed_files=$(git diff --name-only "$remote_ref"...HEAD 2>/dev/null | grep '\.py$')

    if [ -z "$changed_files" ]; then
        echo ""
        return
    fi

    # Extract unique app/module directories
    local apps=()
    while IFS= read -r file; do
        [ -z "$file" ] && continue

        # Get the top-level directory (app name)
        local app=$(echo "$file" | cut -d'/' -f1)

        # Skip common non-app directories
        if [[ "$app" == "tests" ]] || [[ "$app" == "migrations" ]] || \
           [[ "$app" == "docs" ]] || [[ "$app" == "scripts" ]] || \
           [[ "$app" == "config" ]] || [[ "$app" == "settings" ]] || \
           [[ "$app" == "manage.py" ]] || [[ "$app" == "setup.py" ]] || \
           [[ "$app" == "conftest.py" ]]; then
            continue
        fi

        # Check if it's a valid directory with Python files
        if [ -d "$PROJECT_ROOT/$app" ]; then
            # Add to array if not already present
            if [[ ! " ${apps[*]} " =~ " ${app} " ]]; then
                apps+=("$app")
            fi
        fi
    done <<< "$changed_files"

    echo "${apps[*]}"
}

run_django_smart_tests() {
    local smart_tests=$(yaml_get "pre-push.django_smart_tests" "$CONFIG_FILE")

    # Default to true if not specified
    if [ "$smart_tests" = "false" ]; then
        return 0
    fi

    local test_command=$(yaml_get "pre-push.django_test_command" "$CONFIG_FILE")
    [ -z "$test_command" ] && test_command="pytest"

    local apps=$(get_modified_django_apps)

    if [ -z "$apps" ]; then
        echo -e "${DIM}No Python apps modified, skipping smart tests${NC}"
        return 0
    fi

    # Check docker settings
    local docker_enabled=$(yaml_get "docker.enabled" "$CONFIG_FILE")
    local docker_compose=$(yaml_get "docker.compose" "$CONFIG_FILE")
    local docker_container=$(yaml_get "docker.container" "$CONFIG_FILE")
    local compose_file=$(yaml_get "docker.compose_file" "$CONFIG_FILE")
    [ -z "$compose_file" ] && compose_file="docker-compose.yml"

    echo ""
    echo -e "${CYAN}${BOLD}┌──────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}${BOLD}│  Running Django Smart Tests...                               │${NC}"
    echo -e "${CYAN}${BOLD}└──────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    echo -e "${WHITE}${BOLD}Modified apps:${NC} ${MAGENTA}${apps}${NC}"
    echo ""

    local full_cmd="$test_command $apps"

    if [ "$docker_enabled" = "true" ]; then
        if [ "$docker_compose" = "true" ]; then
            full_cmd="docker-compose -f $compose_file exec -T $docker_container $test_command $apps"
        else
            full_cmd="docker exec $docker_container $test_command $apps"
        fi
    fi

    echo -e "${BLUE}▶${NC} ${WHITE}${BOLD}Smart Tests${NC}"
    echo -e "  ${DIM}${full_cmd}${NC}"

    cd "$PROJECT_ROOT" || exit 1

    if eval "$full_cmd" </dev/null; then
        echo -e "  ${GREEN}✔ Passed${NC}"
        echo ""
        return 0
    else
        echo -e "  ${RED}✖ Failed${NC}"
        echo ""
        echo -e "${RED}${BOLD}┌──────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${RED}${BOLD}│  ✖ PUSH REJECTED - Django smart tests failed                 │${NC}"
        echo -e "${RED}${BOLD}└──────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        return 1
    fi
}

# ============================================================================
# Run Custom Commands
# ============================================================================

run_commands() {
    if [ ! -f "$CONFIG_FILE" ]; then
        return 0
    fi

    local enabled=$(yaml_get "pre-push.enabled" "$CONFIG_FILE")
    if [ "$enabled" = "false" ]; then
        return 0
    fi

    # Check file filter
    local only_for_files=$(yaml_get "pre-push.only_for_files" "$CONFIG_FILE")
    if [ -n "$only_for_files" ]; then
        if ! has_matching_files "$only_for_files"; then
            echo -e "${DIM}Skipping pre-push commands (no matching files: ${only_for_files})${NC}"
            return 0
        fi
    fi

    # Check docker settings
    local docker_enabled=$(yaml_get "docker.enabled" "$CONFIG_FILE")
    local docker_compose=$(yaml_get "docker.compose" "$CONFIG_FILE")
    local docker_container=$(yaml_get "docker.container" "$CONFIG_FILE")
    local compose_file=$(yaml_get "docker.compose_file" "$CONFIG_FILE")

    [ -z "$compose_file" ] && compose_file="docker-compose.yml"

    local commands=$(yaml_get_commands "$CONFIG_FILE")

    if [ -z "$commands" ]; then
        return 0
    fi

    echo ""
    echo -e "${CYAN}${BOLD}┌──────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}${BOLD}│  Running pre-push checks...                                  │${NC}"
    echo -e "${CYAN}${BOLD}└──────────────────────────────────────────────────────────────┘${NC}"
    echo ""

    local failed=0

    while IFS= read -r line; do
        [ -z "$line" ] && continue

        local name="${line%%|*}"
        local cmd="${line#*|}"

        echo -e "${BLUE}▶${NC} ${WHITE}${BOLD}${name}${NC}"
        echo -e "  ${DIM}${cmd}${NC}"

        local full_cmd="$cmd"

        if [ "$docker_enabled" = "true" ]; then
            if [ "$docker_compose" = "true" ]; then
                full_cmd="docker-compose -f $compose_file exec -T $docker_container $cmd"
            else
                full_cmd="docker exec $docker_container $cmd"
            fi
        fi

        cd "$PROJECT_ROOT" || exit 1

        if eval "$full_cmd"; then
            echo -e "  ${GREEN}✔ Passed${NC}"
        else
            echo -e "  ${RED}✖ Failed${NC}"
            failed=1
        fi
        echo ""

    done <<< "$commands"

    if [ $failed -eq 1 ]; then
        echo -e "${RED}${BOLD}┌──────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${RED}${BOLD}│  ✖ PUSH REJECTED - Pre-push checks failed                    │${NC}"
        echo -e "${RED}${BOLD}└──────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        echo -e "${YELLOW}Fix the issues above and try again.${NC}"
        echo ""
        return 1
    fi

    echo -e "${GREEN}${BOLD}✔ All pre-push checks passed${NC}"
    echo ""
    return 0
}

# ============================================================================
# Main
# ============================================================================

if ! validate_branch "$branch_name"; then
    exit 1
fi

# Run Django smart tests (if enabled)
if ! run_django_smart_tests; then
    exit 1
fi

if ! run_commands; then
    exit 1
fi

exit 0
